version: "3.8"

services:
  td-agent:
    build: ./td-agent
    container_name: log-collect-td-agent
    user: "0:0"
    environment:
      API_BASE: "${API_BASE}"
      EMPLOYEE_ID: "${EMPLOYEE_ID}"
      PC_ID: "${PC_ID}"
      TZ: "${TZ}"
    volumes:
      - ./td-agent/td-agent.conf:/etc/td-agent/td-agent.conf:ro
      - tdpos:/var/log/td-agent
      - /var/log/audit:/host/var/log/audit:ro
      - /etc/audit:/host/etc/audit:ro
    ports:
      - "24224:24224"
    restart: unless-stopped
    depends_on:
      fix-audit-perm:
        condition: service_healthy

  postfix:
    build: ./postfix
    container_name: log-collect-postfix
    environment:
      TZ: "${TZ}"
    volumes:
      - maildir:/opt/mail
      - postfixlogs:/var/log
      - ./:/hostwork:ro
    ports:
      - "25:25"
    healthcheck:
      test: ["CMD-SHELL", "pidof master >/dev/null 2>&1 || exit 1"]
    restart: unless-stopped

  mail-agent:
    build: ./mail-agent
    container_name: log-collect-mail-agent
    environment:
      API_BASE: "${API_BASE}"
      EMPLOYEE_ID: "${EMPLOYEE_ID}"
      PC_ID: "${PC_ID}"
      TZ: "${TZ}"
      MAILDIR_PATH: "/opt/mail/Maildir"
    volumes:
      - maildir:/opt/mail
      - postfixlogs:/host/var/log:ro
      - mailagentstate:/var/lib/mail-agent
    depends_on:
      td-agent:
        condition: service_started
      postfix:
        condition: service_healthy
    restart: unless-stopped
    command: /bin/sh -c 'while :; do python /app/mail_script.py; sleep 5; done'
  
  proxy-agent:
    build:
      context: .
      dockerfile: ./proxy-agent/Dockerfile
    container_name: log-collect-proxy-agent
    environment:
      API_BASE: "${API_BASE}"
      EMPLOYEE_ID: "${EMPLOYEE_ID}"
      PC_ID: "${PC_ID}"
      TZ: "${TZ}"
    volumes:
      - ./mitmproxy:/root/.mitmproxy
    command: >
      mitmdump -p 8080
      -s /app/email_script.py
      -s /app/http_script.py
      --set confdir=/root/.mitmproxy
      --set termlog_verbosity=info --set flow_detail=2
    ports:
      - "8081:8080"
    depends_on:
      - td-agent
    restart: unless-stopped

  fix-audit-perm:
    image: alpine:3.20
    container_name: fix-audit-perm
    user: "0:0"
    volumes:
      - /var/log/audit:/host/var/log/audit
      - /etc/audit:/host/etc/audit
      - /etc/group:/host/etc/group:ro
      - /etc/logrotate.d:/host/etc/logrotate.d
      - initstate:/state           # ★ 센티넬용
    healthcheck:
      test: ["CMD-SHELL", "[ -f /state/fix_audit_perm.ok ]"]
      interval: 2s
      timeout: 1s
      retries: 15
      start_period: 1s
    command:
      - sh
      - -lc
      - |
        set -euo pipefail

        echo "[fix-audit-perm] start"

        # 그룹: td-agent 있으면 사용, 없으면 root
        if awk -F: '$$1=="td-agent"{exit 0} END{exit 1}' /host/etc/group; then
          GROUP_NAME="td-agent"
        else
          echo "[fix-audit-perm] INFO: host에 'td-agent' 그룹 없음 → root 사용"
          GROUP_NAME="root"
        fi
        echo "[fix-audit-perm] use group=$${GROUP_NAME}"

        # 퍼미션 정리
        chown root:"$${GROUP_NAME}" /host/var/log/audit || true
        chmod 750 /host/var/log/audit || true
        if [ -f /host/var/log/audit/audit.log ]; then
          chown root:"$${GROUP_NAME}" /host/var/log/audit/audit.log || true
          chmod 640 /host/var/log/audit/audit.log || true
        fi
        chown root:"$${GROUP_NAME}" /host/etc/audit || true
        chmod 750 /host/etc/audit || true

        # logrotate 패치
        CREATE_LINE="    create 0640 root $${GROUP_NAME}"
        patch_logrotate() {
          f="$1"; [ -f "$$f" ] || return 1
          cp -f "$$f" "$$f.bak.$(date +%s)" || true
          awk -v cline="$${CREATE_LINE}" '
            /^[[:space:]]*\/var\/log\/audit\/audit\.log[[:space:]]*\{/ { inblk=1 }
            {
              if (inblk && $$1=="create") { $$0=cline; changed=1 }
              print
              if (inblk && /^\}/) {
                if (!changed) { print cline }
                inblk=0; changed=0
              }
            }
          ' "$$f" > "$$f.tmp" && mv "$$f.tmp" "$$f"
          echo "[fix-audit-perm] Patched logrotate: $$f"
          return 0
        }
        patch_logrotate /host/etc/logrotate.d/audit || patch_logrotate /host/etc/logrotate.d/auditd || {
          printf '%s\n' \
            '/var/log/audit/audit.log {' \
            '    daily' \
            '    rotate 7' \
            '    missingok' \
            '    compress' \
            '    delaycompress' \
            '    notifempty' \
            "$${CREATE_LINE}" \
            '    postrotate' \
            '        /usr/sbin/service auditd reload > /dev/null 2>&1 || true' \
            '    endscript' \
            '}' > /host/etc/logrotate.d/auditd
          echo "[fix-audit-perm] Created default /etc/logrotate.d/auditd"
        }

        # ★ 센티넬 찍고 계속 살아있기(health=healthy 유지)
        touch /state/fix_audit_perm.ok
        echo "[fix-audit-perm] OK"
        tail -f /dev/null
    restart: unless-stopped

  fix-mail-perm:
    build: ./fix-mail-perm
    container_name: fix-mail-perm
    volumes:
      - maildir:/opt/mail/Maildir
    restart: unless-stopped
    depends_on:
      - postfix

  cli-wrapper:
    image: alpine:3.20
    container_name: log-collect-cli-wrapper
    depends_on:
      postfix:
        condition: service_healthy
    environment:
      POSTFIX_CTN: "log-collect-postfix"
    command:
      - sh
      - -lc
      - |-
        set -e
        # 시스템 PATH에 이미 들어있는 /usr/local/bin 에 설치
        install -d /hostbin

        # 기존 mail이 래퍼가 아니면 백업
        if [ -f /hostbin/mail ] && ! grep -q 'docker exec -i .* /usr/bin/mailx' /hostbin/mail 2>/dev/null; then
          cp -f /hostbin/mail "/hostbin/mail.bak.$(date +%s)"
        fi

        # mailx 래퍼 (★ compose가 $를 치환하지 못하게 $를 $$로 이스케이프)
        cat >/hostbin/mail <<'EOS'
        #!/usr/bin/env sh
        set -eu
        CTN="$${POSTFIX_CTN:-log-collect-postfix}"
        exec docker exec -i "$$CTN" /usr/bin/mailx "$$@"
        EOS
        chmod +x /hostbin/mail

        echo "Installed /usr/local/bin/mail -> docker exec -i \${POSTFIX_CTN:-log-collect-postfix} /usr/bin/mailx"
    volumes:
      - /usr/local/bin:/hostbin
      - ${HOME}/.local/bin:/hostuserbin
      - /var/run/docker.sock:/var/run/docker.sock:ro
    restart: "no"

  sudo-securepath-setup:
    image: debian:stable-slim
    container_name: sudo-securepath-setup
    restart: "no"
    volumes:
      - /etc/sudoers:/host-etc/sudoers
      - /etc/sudoers.d:/host-etc-sudoers.d
    command:
      - sh
      - -lc
      - |-
        set -euo pipefail
        export DEBIAN_FRONTEND=noninteractive
        apt-get update >/dev/null
        apt-get install -y --no-install-recommends sudo >/dev/null

        mkdir -p /host-etc-sudoers.d

        extract() {
          grep -hE '^[[:space:]]*Defaults.*secure_path="[^"]+"' "$$@" 2>/dev/null \
          | tail -n1 | sed -E 's/.*secure_path="([^"]+)".*/\1/'
        }
        CUR="$$(extract /host-etc/sudoers /host-etc-sudoers.d/* || true)"
        [ -n "$$CUR" ] || CUR="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

        NEW="/usr/local/sbin"
        IFS=:; for p in $$CUR; do
          [ -n "$$p" ] || continue
          case ":$$NEW:" in *":$$p:"*) ;; *) NEW="$$NEW:$$p";; esac
        done; unset IFS

        [ -n "$$NEW" ] || NEW="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

        cat > /host-etc-sudoers.d/99-securepath-local <<EOF
        # added by docker service sudo-securepath-setup
        Defaults secure_path="$$NEW"
        EOF

        visudo -q -cf /host-etc-sudoers.d/99-securepath-local

        if ! grep -q '^[[:space:]]*#includedir[[:space:]]\+/etc/sudoers.d' /host-etc/sudoers; then
          cp -a /host-etc/sudoers "/host-etc-sudoers.bak.$$(date +%s)"
          printf '\n# added by docker service sudo-securepath-setup\n#includedir /etc/sudoers.d\n' >> /host-etc/sudoers
        fi

        echo "secure_path set to: $$NEW"
        echo "Verify on host: sudo -V | grep -i secure_path"

  install-umount-wrapper:
    image: bash:5.2
    container_name: install-umount-wrapper
    restart: "no"
    depends_on:
      - sudo-securepath-setup
    network_mode: "none"
    volumes:
      - /usr/local/sbin:/host-sbin
      - /usr/local/lib:/host-lib
      - ./auto-device-watch/auto_device_watch.sh:/src/auto_device_watch.sh:ro
    command:
      - sh
      - -lc
      - |-
        set -euo pipefail

        install -d /host-sbin /host-lib
        install -Dm755 /src/auto_device_watch.sh /host-lib/auto_device_watch.sh

        if [ -f /host-sbin/umount ]; then
          if ! grep -q "auto_device_watch wrapper" /host-sbin/umount 2>/dev/null; then
            echo "Backing up existing /usr/local/sbin/umount -> /usr/local/sbin/umount.bak"
            cp -f /host-sbin/umount /host-sbin/umount.bak || true
          fi
        fi

        cat >/host-sbin/umount << 'EOF'
        #!/bin/bash
        # auto_device_watch wrapper
        set -u

        REAL_UMOUNT="/usr/bin/umount"
        [ -x "$$REAL_UMOUNT" ] || REAL_UMOUNT="/bin/umount"

        NO_AUTO="$${NO_AUTO_FILE:-/run/auto_device_watch.NO_AUTO}"
        CLEANER="$${CLEANER:-/usr/local/lib/auto_device_watch.sh}"

        cleanup() { rm -f "$$NO_AUTO" 2>/dev/null || true; }
        trap cleanup EXIT

        targets=()
        for a in "$$@"; do
          case "$$a" in -*) ;; *) targets+=("$$a");; esac
        done

        touch "$$NO_AUTO" 2>/dev/null || true

        set +e
        "$$REAL_UMOUNT" "$$@"
        rc=$$?
        set -e

        if [ -e "$$CLEANER" ] && [ $${#targets[@]} -gt 0 ]; then
          t_clean=()
          for t in "$${targets[@]}"; do
            case "$$t" in
              /media/*|/dev/loop*|*.img) t_clean+=("$$t");;
            esac
          done
          if [ $${#t_clean[@]} -gt 0 ]; then
            USER_NAME="$${SUDO_USER:-$$USER}" bash "$$CLEANER" umount-clean "$${t_clean[@]}"
          fi
        fi

        exit "$$rc"
        EOF

        chmod 755 /host-sbin/umount
        echo "Installed: /usr/local/sbin/umount (wrapper) and /usr/local/lib/auto_device_watch.sh"

  auto-device-watch:
    build: ./auto-device-watch
    container_name: auto-device-watch
    user: "0:0"
    security_opt:
    - apparmor=unconfined
    - seccomp=unconfined
    environment:
      EMPLOYEE_ID: "${EMPLOYEE_ID}"
      USER_NAME: "${EMPLOYEE_ID}"
      AUTO_MOUNT: "1"
      MOUNT_IN_HOST: "1"
      AUDIT_KEY: "usb_copy"
      AUDIT_COMM: "cp"
      TZ: "${TZ}"
    pid: "host"
    cap_add:
      - SYS_ADMIN                    # mount 수행
      - AUDIT_CONTROL                # auditctl 권한
    privileged: true
    volumes:
      - type: bind
        source: /home
        target: /home
        bind: { propagation: rshared }
      - type: bind
        source: /media
        target: /media
        bind: { propagation: rshared }
      - /etc/audit:/host/etc/audit
    restart: unless-stopped
    depends_on:
      fix-audit-perm:
        condition: service_healthy

volumes:
    initstate:
    tdpos:
      name: logcollect_tdpos
    maildir: {}
    postfixlogs:
      name: logcollect_postfixlogs
    mailagentstate: {}
